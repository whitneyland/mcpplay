//
//  Verovio.swift
//  RiffMCP
//
//  Created by Lee Whitney on 6/14/25.
//

import Foundation
import AppKit

@MainActor
class Verovio {

    static func svg(from meiXML: String, _ pageWidth: Int = 1700, _ pageHeight: Int = 2200) -> String? {
        return VerovioManager.shared.svg(from: meiXML, pageWidth: pageWidth, pageHeight: pageHeight)
    }

    /// Post-processes a Verovio-generated SVG string by dynamically resizing instrument
    /// labels based on a scaling factor.
    ///
    /// First, reads the base font size from the first instrument label it finds.
    /// It then uses the provided scaling factors to calculate new font
    /// sizes and injects a CSS `<style>` block to apply them. This approach tries to be
    /// robust against future changes in Verovio's default font sizes.
    ///
    /// The modification targets only the instrument labels via CSS classes
    /// (`.label` and `.subStaffLabel`) and using `!important` to override inline styles.
    ///
    /// - Parameters:
    ///   - svgString: The raw SVG string generated by Verovio.
    ///   - firstSystemScale: The scaling factor for full instrument labels (e.g.,
    ///                       0.6 for 60%). Defaults to 0.6.
    ///   - subsequentScale: The scaling factor for abbreviated instrument labels.
    ///                      Defaults to 0.55.
    /// - Returns: The modified SVG string with the appended style block, or the
    ///            original string if modification is not possible.
    static func postProcessSvgString(
        _ svgString: String,
        firstSystemScale: Double = 0.6,
        subsequentScale: Double = 0.55
    ) -> String {
        // --- Step 1: Dynamically find the base font size from the SVG ---

        // This regex is specifically crafted to find the font-size value within the
        // first <g class="label"> element. It's much safer than a global search.
        // Pattern: `g class="label"` -> any characters -> `font-size="` -> CAPTURE THE NUMBER
        let pattern = #"g class="label".*?font-size="(\d+)"#

        let baseFontSize: Int

        do {
            let regex = try NSRegularExpression(pattern: pattern)
            if let match = regex.firstMatch(in: svgString, options: [], range: NSRange(svgString.startIndex..., in: svgString)),
               let range = Range(match.range(at: 1), in: svgString),
               let foundSize = Int(svgString[range]) {
                baseFontSize = foundSize
            } else {
                // Fallback to a known default if no label is found.
                baseFontSize = 405
            }
        } catch {
            // In case of a regex error, return the original string.
            Log.io.error("SVG Post-processing Error: Invalid Regex. \(error.localizedDescription, privacy: .public)")
            return svgString
        }

        // --- Step 2: Calculate the new font sizes based on the scaling factors ---
        let newFirstSystemSize = Int(Double(baseFontSize) * firstSystemScale)

        // For abbreviated labels, we scale from the same base size.
        let newSubsequentSize = Int(Double(baseFontSize) * subsequentScale)

        // --- Step 3: Inject the CSS block with the calculated sizes ---

        let closingTag = "</svg>"
        guard let closingTagRange = svgString.range(of: closingTag, options: .backwards) else {
            return svgString
        }

        // Note the `px` unit, which refers to the SVG's internal coordinate system units.
        let styleBlock = """

        <style type="text/css">
          /* First system (full labels) - Scaled to \(newFirstSystemSize)px */
          g.label text,
          g.label tspan             { font-size: \(newFirstSystemSize)px !important; }

          /* Subsequent systems (abbreviated labels) - Scaled to \(newSubsequentSize)px */
          g.subStaffLabel text,
          g.subStaffLabel tspan     { font-size: \(newSubsequentSize)px !important; }
        </style>
        """

        var newSvgString = svgString
        newSvgString.insert(contentsOf: styleBlock, at: closingTagRange.lowerBound)

        return newSvgString
    }

    static func svgFromSimpleTestXml() -> String? {
        // Simple MEI XML with a few test notes (C, E, G)
        let meiXML = """
        <?xml version="1.0" encoding="UTF-8"?>
        <mei xmlns="http://www.music-encoding.org/ns/mei" meiversion="5.0">
          <meiHead>
            <fileDesc>
              <titleStmt>
                <title>RiffMCP Test</title>
              </titleStmt>
              <pubStmt/>
            </fileDesc>
          </meiHead>
          <music>
            <body>
              <mdiv>
                <score>
                  <scoreDef meter.count="4" meter.unit="4" key.sig="0">
                    <staffGrp>
                      <staffDef n="1" lines="5" clef.shape="G" clef.line="2"/>
                    </staffGrp>
                  </scoreDef>
                  <section>
                    <measure n="1">
                      <staff n="1">
                        <layer n="1">
                          <note pname="c" oct="4" dur="4"/>
                          <note pname="e" oct="4" dur="4"/>
                          <note pname="g" oct="4" dur="4"/>
                          <note pname="c" oct="5" dur="4"/>
                        </layer>
                      </staff>
                    </measure>
                  </section>
                </score>
              </mdiv>
            </body>
          </music>
        </mei>        
        """
        return VerovioManager.shared.svg(from: meiXML, pageWidth: 2200, pageHeight: 2200)
    }
}
