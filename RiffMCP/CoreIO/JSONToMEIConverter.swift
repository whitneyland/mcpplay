//
//  JSONToMEIConverter.swift
//  Created 26 Jun 2025
//
//  Convert JSON music format → MEI v5.x XML
//

import Foundation

public enum JSONToMEIConverter {

    /// When a duration isn’t an exact power-of-two or dotted value, we
    /// “snap” it to the closest power-of-two **only if** the relative error
    /// is ≤ this value (25 % by default).
    private static let snapTolerance: Double = 0.25
    // ---------------------------------------------------------------------

    public enum ConversionError: Error, LocalizedError {
        case decodingFailed(Error)
        case unsupportedPitchFormat(String)
        case unknownInstrument(String)

        public var errorDescription: String? {
            switch self {
            case .decodingFailed(let err):
                return "Failed to decode JSON: \(err.localizedDescription)"
            case .unsupportedPitchFormat(let p):
                return "The pitch ‘\(p)’ is in an unrecognized format."
            case .unknownInstrument(let inst):
                return "The instrument ‘\(inst)’ is not in the recognized list."
            }
        }
    }

    public static func convert(from jsonData: Data) throws -> String {
        let composition: Composition
        do {
            composition = try JSONDecoder().decode(Composition.self, from: jsonData)
        } catch {
            throw ConversionError.decodingFailed(error)
        }

        // --- Build XML document ---
        let mei = XMLElement(name: "mei")
        mei.addNamespace(
            XMLNode.namespace(withName: "",
                              stringValue: "http://www.music-encoding.org/ns/mei") as! XMLNode
        )
        mei.addAttribute(att("meiversion", "5.0"))

        mei.addChild(try buildMeiHead(for: composition))
        mei.addChild(try buildMusic(for: composition))

        let doc = XMLDocument(rootElement: mei)
        doc.characterEncoding = "UTF-8"
        doc.version = "1.0"
        return doc.xmlString(options: [.nodePrettyPrint, .nodeCompactEmptyElement])
    }
}

// MARK: - XML building
private extension JSONToMEIConverter {

    static func buildMeiHead(for piece: Composition) throws -> XMLElement {
        let head = XMLElement(name: "meiHead")
        let fileDesc = XMLElement(name: "fileDesc")

        let titleStmt = XMLElement(name: "titleStmt")
        titleStmt.addChild(XMLElement(name: "title",
                                      stringValue: piece.title ?? "Untitled Composition"))
        fileDesc.addChild(titleStmt)

        let pubStmt = XMLElement(name: "pubStmt")
        pubStmt.addChild(XMLElement(name: "publisher",
                                    stringValue: "Generated by MEIConverter"))
        fileDesc.addChild(pubStmt)

        head.addChild(fileDesc)
        return head
    }

    static func buildMusic(for piece: Composition) throws -> XMLElement {
        let music  = XMLElement(name: "music")
        let body   = XMLElement(name: "body")
        let mdiv   = XMLElement(name: "mdiv")
        let score  = XMLElement(name: "score")

        let processedTracks = try processTracks(piece.tracks)
        score.addChild(try buildScoreDef(processedTracks: processedTracks))
        score.addChild(try buildSection(for: piece,
                                        processedTracks: processedTracks))

        mdiv.addChild(score)
        body.addChild(mdiv)
        music.addChild(body)
        return music
    }

    static func buildScoreDef(processedTracks: [ProcessedTrack]) throws -> XMLElement {
        let scoreDef = XMLElement(name: "scoreDef")
        scoreDef.addChild(makeAttributeElement("meterSig",
                                               attributes: ["count": "4", "unit": "4"]))
        scoreDef.addChild(makeAttributeElement("keySig",
                                               attributes: ["sig": "0", "pname": "c"]))

        // ✨ NEW: How many distinct instruments are there?
        let uniqueInstruments = Set(processedTracks.map { $0.instrumentName })
        let hasMultipleInstruments = uniqueInstruments.count > 1
        let singleInstrumentIsPiano =
            uniqueInstruments.count == 1 &&
            Instruments.isPianoInstrument(uniqueInstruments.first!)

        // decide if we show labels
        let showLabels = hasMultipleInstruments || !singleInstrumentIsPiano

        let staffGrp = XMLElement(name: "staffGrp")
        if hasMultipleInstruments {                         // ✨ NEW
            staffGrp.addAttribute(att("symbol", "bracket"))
        }

        var currentPianoGroup: XMLElement?
        var currentTrackIndex = -1

        for processedTrack in processedTracks {
            let staffDef = buildStaffDef(for: processedTrack,
                                         showLabel: showLabels)

            if isPiano(processedTrack) {
                if processedTrack.originalTrackIndex != currentTrackIndex {
                    currentTrackIndex = processedTrack.originalTrackIndex
                    currentPianoGroup = XMLElement(name: "staffGrp")
                    currentPianoGroup!.addAttribute(att("symbol", "brace"))
                }
                currentPianoGroup?.addChild(staffDef)

                if processedTrack.clef.shape == "F" {          // bass staff closes group
                    if let group = currentPianoGroup { staffGrp.addChild(group) }
                    currentPianoGroup = nil
                }
            } else {
                staffGrp.addChild(staffDef)
                currentTrackIndex = processedTrack.originalTrackIndex
            }
        }

        scoreDef.addChild(staffGrp)
        return scoreDef
    }

    static func buildStaffDef(for processedTrack: ProcessedTrack,
                              showLabel: Bool) -> XMLElement {

        let staffDef = XMLElement(name: "staffDef")
        staffDef.addAttribute(att("n", "\(processedTrack.staffIndex)"))
        staffDef.addAttribute(att("lines", "5"))
        staffDef.addAttribute(att("label", processedTrack.label))   // harmless if blank

        if showLabel && !processedTrack.label.isEmpty {
            let labelElt = XMLElement(name: "label",
                                      stringValue: processedTrack.label)
            staffDef.addChild(labelElt)
        }

        let instrDef = makeAttributeElement("instrDef",
                                            attributes: ["midi.instrnum": "\(processedTrack.midiProgram)"])
        staffDef.addChild(instrDef)

        let clef = makeAttributeElement("clef",
                                        attributes: ["shape": processedTrack.clef.shape,
                                                     "line": "\(processedTrack.clef.line)"])
        staffDef.addChild(clef)
        return staffDef
    }

    static func buildSection(for piece: Composition,
                             processedTracks: [ProcessedTrack]) throws -> XMLElement {

        let section = XMLElement(name: "section")
        let (sortedEvents, totalMeasures) =
            try processAndCalculateMeasures(piece: piece,
                                            processedTracks: processedTracks)
        let eventsByMeasure = groupEventsByMeasure(sortedEvents)

        for measureIndex in 0..<totalMeasures {
            let measure = XMLElement(name: "measure")
            measure.addAttribute(att("n", "\(measureIndex + 1)"))

            for processedTrack in processedTracks {
                let staff = XMLElement(name: "staff")
                staff.addAttribute(att("n", "\(processedTrack.staffIndex)"))

                let layer = XMLElement(name: "layer")
                layer.addAttribute(att("n", "1"))

                // initial tempo
                if measureIndex == 0 && processedTrack.staffIndex == 1 {
                    let tempo = makeAttributeElement("tempo",
                        attributes: ["place":"above", "tstamp":"1.0",
                                     "midi.bpm":"\(Int(piece.tempo.rounded()))"])
                    let dir = XMLElement(name: "dir"); dir.addChild(tempo)
                    layer.addChild(dir)
                }

                try populateLayer(layer,
                                  events: eventsByMeasure[measureIndex]?[processedTrack.staffIndex] ?? [],
                                  beatsPerMeasure: 4.0)
                staff.addChild(layer)
                measure.addChild(staff)
            }
            section.addChild(measure)
        }
        return section
    }

    static func populateLayer(_ layer: XMLElement,
                              events: [Event],
                              beatsPerMeasure: Double) throws {
        var beatCursor = 0.0
        for event in events.sorted(by: { $0.time < $1.time }) {
            let eventStartBeat = event.time.truncatingRemainder(dividingBy: beatsPerMeasure)

            if eventStartBeat > beatCursor {
                try addRests(to: layer, for: eventStartBeat - beatCursor)
            }

            layer.addChild(try buildMusicalEventElement(event: event))
            beatCursor = eventStartBeat + event.dur
        }
        if beatCursor < beatsPerMeasure {
            try addRests(to: layer, for: beatsPerMeasure - beatCursor)
        }
    }
}

// MARK: - Element helpers
private extension JSONToMEIConverter {

    static func buildMusicalEventElement(event: Event) throws -> XMLElement {
        if event.pitches.isEmpty {
            return XMLElement(name: "comment", stringValue: "Empty event")
        }

        let element = XMLElement(name: event.pitches.count > 1 ? "chord" : "note")
        try element.addAttributes(from: durationToAttributes(beats: event.dur))

        if let velocity = event.vel {
            element.addAttribute(att("vel", "\(velocity.clamped(to: 0...127))"))
        }

        if event.pitches.count == 1 {
            try element.addAttributes(from: pitchToAttributes(event.pitches[0]))
        } else {
            for pitch in event.pitches {
                let noteElement = XMLElement(name: "note")
                try noteElement.addAttributes(from: pitchToAttributes(pitch))
                element.addChild(noteElement)
            }
        }
        return element
    }

    static func addRests(to layer: XMLElement, for duration: Double) throws {
        guard duration > 0 else { return }
        let rest = XMLElement(name: "rest")
        try rest.addAttributes(from: durationToAttributes(beats: duration))
        layer.addChild(rest)
    }

    // -----------------------------------------------------------------
    //  Duration → MEI attributes (with snapping)
    // -----------------------------------------------------------------
    static func durationToAttributes(beats: Double) throws -> [XMLNode] {

        guard beats.isFinite, beats > 0 else {
            Log.io.info("Warning: invalid duration \(beats, privacy: .public); using quarter.")
            return [att("dur", "4")]
        }

        // 1) dotted literals
        switch beats {
        case 1.5:  return [att("dur","4"), att("dots","1")]
        case 3.0:  return [att("dur","2"), att("dots","1")]
        case 0.75: return [att("dur","8"), att("dots","1")]
        default: break
        }

        // 2) exact power-of-two lookup
        let table: [Double:String] = [4:"1", 2:"2", 1:"4", 0.5:"8",
                                      0.25:"16", 0.125:"32", 0.0625:"64"]
        if let dur = table[beats] { return [att("dur", dur)] }

        // 3) snap to nearest power-of-two within tolerance 🛡️
        if let nearest = table.min(by: { abs($0.key - beats) < abs($1.key - beats) }) {
            let relError = abs(nearest.key - beats) / beats
            if relError <= snapTolerance {
                return [att("dur", nearest.value)]
            }
        }

        // 4) unsupported → placeholder
        Log.io.info("Warning: unsupported duration \(beats, privacy: .public); using quarter.")
        return [att("dur", "4"), att("artic", "stacc")]
    }

    static func pitchToAttributes(_ pitch: PitchValue) throws -> [XMLNode] {
        let parsed: (pname: String, oct: Int, accid: String?)
        switch pitch {
        case .name(let string): parsed = try noteNameToPitch(name: string)
        case .midi(let number): parsed = midiToPitch(midi: number.clamped(to: 0...127))
        }

        var attributes = [att("pname", parsed.pname), att("oct", "\(parsed.oct)")]
        if let accid = parsed.accid { attributes.append(att("accid", accid)) }
        return attributes
    }

    static func att(_ name: String, _ value: String) -> XMLNode {
        XMLNode.attribute(withName: name, stringValue: value) as! XMLNode
    }

    static func makeAttributeElement(_ name: String,
                                     attributes: [String:String]) -> XMLElement {
        let el = XMLElement(name: name)
        attributes.forEach { el.addAttribute(att($0.key, $0.value)) }
        return el
    }
}

// MARK: - Data models & processing
private extension JSONToMEIConverter {

    // Codable JSON
    struct Composition: Decodable {
        let title: String?
        let tempo: Double
        let tracks: [Track]
    }
    struct Track: Decodable {
        let instrument: String?
        let events: [Event]
    }
    struct Event: Decodable {
        let time: Double
        let pitches: [PitchValue]
        let dur: Double
        let vel: Int?
    }
    enum PitchValue: Decodable {
        case name(String)
        case midi(Int)
        init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            if let n = try? container.decode(Int.self) { self = .midi(n) }
            else { self = .name(try container.decode(String.self)) }
        }
    }

    // Internal processing
    class ProcessedTrack {
        let originalTrackIndex: Int
        let staffIndex: Int
        let instrumentName: String
        let label: String
        let midiProgram: Int
        let clef: ClefInfo

        init(originalTrackIndex: Int, staffIndex: Int,
             instrumentName: String, label: String,
             midiProgram: Int, clef: ClefInfo) {
            self.originalTrackIndex = originalTrackIndex
            self.staffIndex = staffIndex
            self.instrumentName = instrumentName
            self.label = label
            self.midiProgram = midiProgram
            self.clef = clef
        }
    }
    struct ProcessedEvent {
        let event: Event
        let staffIndex: Int
    }

    static func isPiano(_ processedTrack: ProcessedTrack) -> Bool {
        Instruments.isPianoInstrument(processedTrack.instrumentName)
    }

    static func processAndCalculateMeasures(piece: Composition,
                                            processedTracks: [ProcessedTrack])
        throws -> (sortedEvents:[ProcessedEvent], totalMeasures:Int) {

        let allEvents = try piece.tracks.enumerated().flatMap { trackIndex, track -> [ProcessedEvent] in
            let staffsForTrack = processedTracks.filter { $0.originalTrackIndex == trackIndex }
            let isPianoTrack = staffsForTrack.count > 1

            return try track.events.map { event in
                var targetStaffIndex = staffsForTrack.first!.staffIndex
                if isPianoTrack,
                   let trebleStaff = staffsForTrack.first,
                   let bassStaff   = staffsForTrack.last {
                    let firstPitchMidi = try pitchToMidi(event.pitches.first ?? .name("C4"))
                    targetStaffIndex = firstPitchMidi >= 60 ? trebleStaff.staffIndex : bassStaff.staffIndex
                }
                return ProcessedEvent(event: event, staffIndex: targetStaffIndex)
            }
        }
        let sortedEvents = allEvents.sorted { $0.event.time < $1.event.time }

        let beatsPerMeasure = 4.0
        let totalBeats  = sortedEvents.last.map { $0.event.time + $0.event.dur } ?? 0
        let totalMeasures = max(1, Int(ceil(totalBeats / beatsPerMeasure)))

        return (sortedEvents, totalMeasures)
    }

    static func groupEventsByMeasure(_ sortedEvents: [ProcessedEvent])
        -> [Int:[Int:[Event]]] {

        var measures: [Int:[Int:[Event]]] = [:]
        let beatsPerMeasure = 4.0

        for processedEvent in sortedEvents {
            let measureIndex = Int(floor(processedEvent.event.time / beatsPerMeasure))
            measures[measureIndex, default: [:]][processedEvent.staffIndex, default: []]
                .append(processedEvent.event)
        }
        return measures
    }

    static func processTracks(_ tracks: [Track]) throws -> [ProcessedTrack] {
        var processedTracks: [ProcessedTrack] = []
        var staffCount = 0

        for (trackIndex, track) in tracks.enumerated() {
            let requestedInstrument = track.instrument ?? "grand_piano"
            let instrumentName = Instruments.getMidiProgram(for: requestedInstrument) != nil
                                ? requestedInstrument
                                : "grand_piano"
            let midiProgram = Instruments.getMidiProgram(for: instrumentName) ?? 0

            if Instruments.isPianoInstrument(instrumentName) {
                staffCount += 1
                processedTracks.append(
                    ProcessedTrack(originalTrackIndex: trackIndex,
                                   staffIndex: staffCount,
                                   instrumentName: instrumentName,
                                   label: Instruments.getDisplayName(for: instrumentName) ?? instrumentName.replacingOccurrences(of: "_", with: " ").capitalized,
                                   midiProgram: midiProgram,
                                   clef: clefFromString("treble")))
                staffCount += 1
                processedTracks.append(
                    ProcessedTrack(originalTrackIndex: trackIndex,
                                   staffIndex: staffCount,
                                   instrumentName: instrumentName,
                                   label: "",
                                   midiProgram: midiProgram,
                                   clef: clefFromString("bass")))
            } else {
                staffCount += 1
                processedTracks.append(
                    ProcessedTrack(originalTrackIndex: trackIndex,
                                   staffIndex: staffCount,
                                   instrumentName: instrumentName,
                                   label: Instruments.getDisplayName(for: instrumentName) ?? instrumentName.replacingOccurrences(of: "_", with: " ").capitalized,
                                   midiProgram: midiProgram,
                                   clef: clefFromString(Instruments.getClef(for: instrumentName))))
            }
        }
        return processedTracks
    }

    // MARK: pitch helpers
    static func noteNameToPitch(name: String)
        throws -> (pname: String, oct: Int, accid: String?) {

        let regex = try! NSRegularExpression(pattern: #"^([A-Ga-g])([#sb]?)(-?\d+)$"#)
        guard let match = regex.firstMatch(in: name, options: [],
                                           range: NSRange(name.startIndex..., in: name)),
              let pRange = Range(match.range(at:1), in: name),
              let aRange = Range(match.range(at:2), in: name),
              let oRange = Range(match.range(at:3), in: name)
        else { throw ConversionError.unsupportedPitchFormat(name) }

        let pname = String(name[pRange]).lowercased()
        let accidentalStr = String(name[aRange])
        let oct = Int(name[oRange]) ?? 4

        let accid: String?
        switch accidentalStr {
        case "#", "s": accid = "s"
        case "b":      accid = "f"
        default:       accid = nil
        }
        return (pname, oct, accid)
    }

    static func midiToPitch(midi: Int)
        -> (pname: String, oct: Int, accid: String?) {

        let noteNames = ["c","c","d","d","e","f","f","g","g","a","a","b"]
        let noteAccs  = [nil,"s",nil,"s",nil,nil,"s",nil,"s",nil,"s",nil]
        let octave = (midi / 12) - 1
        let idx = midi % 12
        return (noteNames[idx], octave, noteAccs[idx])
    }

    static func pitchToMidi(_ pitch: PitchValue) throws -> Int {
        switch pitch {
        case .midi(let number):
            return number.clamped(to: 0...127)
        case .name(let name):
            let p = try noteNameToPitch(name: name)
            let base = ["c":0,"d":2,"e":4,"f":5,"g":7,"a":9,"b":11][p.pname]!
            var midi = (p.oct + 1) * 12 + base
            if p.accid == "s" { midi += 1 }
            else if p.accid == "f" { midi -= 1 }
            return midi.clamped(to: 0...127)
        }
    }
}

// MARK: - Clef Helper
private extension JSONToMEIConverter {
    struct ClefInfo { let shape: String; let line: Int }
    
    static func clefFromString(_ clefName: String) -> ClefInfo {
        switch clefName {
        case "treble": return ClefInfo(shape: "G", line: 2)
        case "bass":   return ClefInfo(shape: "F", line: 4)
        case "alto":   return ClefInfo(shape: "C", line: 3)
        case "tenor":  return ClefInfo(shape: "C", line: 4)
        default:       return ClefInfo(shape: "G", line: 2) // default to treble
        }
    }
}

// MARK: - XML attribute convenience
fileprivate extension XMLElement {
    func addAttributes(from nodes: [XMLNode]) throws {
        for node in nodes where node.kind == .attribute {
            addAttribute(node)
        }
    }
}

// MARK: - Utility extension
private extension Comparable {
    /// Clamp value to closed range.
    func clamped(to range: ClosedRange<Self>) -> Self {
        min(max(self, range.lowerBound), range.upperBound)
    }
}
