//
//  MEIConverter.swift
//  Created 26 Jun 2025
//
//  Convert JSON music format â†’ MEI v5.x
//

import Foundation

/// A component to convert our JSON music format into standards-compliant MEI 5.x XML.
public enum MEIConverter {

    /// An error that can occur during the conversion process.
    public enum ConversionError: Error, LocalizedError {
        case decodingFailed(Error)
        case unsupportedPitchFormat(String)
        case unknownInstrument(String)

        public var errorDescription: String? {
            switch self {
            case .decodingFailed(let error):
                return "Failed to decode JSON: \(error.localizedDescription)"
            case .unsupportedPitchFormat(let pitch):
                return "The pitch '\(pitch)' is in an unrecognized format."
            case .unknownInstrument(let instrument):
                return "The instrument '\(instrument)' is not in the recognized list."
            }
        }
    }

    /// Converts music composition data from JSON format to MEI 5.x XML format.
    ///
    /// - Parameter jsonData: The input `Data` object containing the music composition in the specified JSON format.
    /// - Returns: A `String` containing the MEI 5.x XML representation of the music.
    /// - Throws: `MEIConverter.ConversionError` if the JSON is invalid or data is missing.
    public static func convert(from jsonData: Data) throws -> String {
        let composition: Composition
        do {
            composition = try JSONDecoder().decode(Composition.self, from: jsonData)
        } catch {
            throw ConversionError.decodingFailed(error)
        }

        // --- Build XML Document Structure ---

        let mei = XMLElement(name: "mei")
        mei.addNamespace(XMLNode.namespace(withName: "", stringValue: "http://www.music-encoding.org/ns/mei") as! XMLNode)
        mei.addAttribute(att("meiversion", "5.0"))

        mei.addChild(try buildMeiHead(for: composition))
        mei.addChild(try buildMusic(for: composition))

        // --- Finalize and Output ---

        let doc = XMLDocument(rootElement: mei)
        doc.characterEncoding = "UTF-8"
        doc.version = "1.0"

        return doc.xmlString(options: [.nodePrettyPrint, .nodeCompactEmptyElement])
    }
}

// MARK: - XML Building Logic

private extension MEIConverter {

    static func buildMeiHead(for piece: Composition) throws -> XMLElement {
        let head = XMLElement(name: "meiHead")

        let fileDesc = XMLElement(name: "fileDesc")
        let titleStmt = XMLElement(name: "titleStmt")
        let titleString = piece.title ?? "Untitled Composition"
        titleStmt.addChild(XMLElement(name: "title", stringValue: titleString))
        fileDesc.addChild(titleStmt)

        let pubStmt = XMLElement(name: "pubStmt")
        pubStmt.addChild(XMLElement(name: "publisher", stringValue: "Generated by MEIConverter"))
        fileDesc.addChild(pubStmt)

        head.addChild(fileDesc)
        return head
    }

    static func buildMusic(for piece: Composition) throws -> XMLElement {
        let music = XMLElement(name: "music")
        let body = XMLElement(name: "body")
        let mdiv = XMLElement(name: "mdiv")
        let score = XMLElement(name: "score")

        let processedTracks = try processTracks(piece.tracks)

        score.addChild(try buildScoreDef(processedTracks: processedTracks))
        score.addChild(try buildSection(for: piece, processedTracks: processedTracks))

        mdiv.addChild(score)
        body.addChild(mdiv)
        music.addChild(body)
        return music
    }

    static func buildScoreDef(processedTracks: [ProcessedTrack]) throws -> XMLElement {
        let scoreDef = XMLElement(name: "scoreDef")

        scoreDef.addChild(makeAttributeElement("meterSig", attributes: ["count": "4", "unit": "4"]))
        scoreDef.addChild(makeAttributeElement("keySig", attributes: ["sig": "0", "pname": "c"]))

        let staffGrp = XMLElement(name: "staffGrp")

        var currentPianoGroup: XMLElement? = nil
        var currentTrackIndex = -1

        for pTrack in processedTracks {
            let staffDef = buildStaffDef(for: pTrack)

            if isPiano(pTrack) {
                if pTrack.originalTrackIndex != currentTrackIndex {
                    // This is the first staff of a new piano track, start a group.
                    currentTrackIndex = pTrack.originalTrackIndex
                    currentPianoGroup = XMLElement(name: "staffGrp")
                    currentPianoGroup!.addAttribute(att("symbol", "brace"))
                }
                currentPianoGroup?.addChild(staffDef)

                // If this is the bass clef staff, the piano group is complete.
                if pTrack.clef.shape == "F" {
                    if let group = currentPianoGroup {
                        staffGrp.addChild(group)
                    }
                    currentPianoGroup = nil // Reset for the next instrument.
                }
            } else {
                // Not a piano, just add the staff definition directly.
                staffGrp.addChild(staffDef)
                currentTrackIndex = pTrack.originalTrackIndex // Update track index
            }
        }

        scoreDef.addChild(staffGrp)
        return scoreDef
    }

    static func buildStaffDef(for pTrack: ProcessedTrack) -> XMLElement {
        let staffDef = XMLElement(name: "staffDef")
        staffDef.addAttribute(att("n", "\(pTrack.staffIndex)"))
        staffDef.addAttribute(att("lines", "5"))
        staffDef.addAttribute(att("label", pTrack.label))

        let instrDef = makeAttributeElement("instrDef", attributes: ["midi.instrnum": "\(pTrack.midiProgram)"])
        staffDef.addChild(instrDef)

        let clef = makeAttributeElement("clef", attributes: ["shape": pTrack.clef.shape, "line": "\(pTrack.clef.line)"])
        staffDef.addChild(clef)

        return staffDef
    }

    static func buildSection(for piece: Composition, processedTracks: [ProcessedTrack]) throws -> XMLElement {
        let section = XMLElement(name: "section")

        let (sortedEvents, totalMeasures) = try processAndCalculateMeasures(piece: piece, processedTracks: processedTracks)
        let measuresByTime = groupEventsByMeasure(sortedEvents)

        for i in 0..<totalMeasures {
            let measure = XMLElement(name: "measure")
            measure.addAttribute(att("n", "\(i + 1)"))

            for pTrack in processedTracks {
                let staff = XMLElement(name: "staff")
                staff.addAttribute(att("n", "\(pTrack.staffIndex)"))
                let layer = XMLElement(name: "layer")
                layer.addAttribute(att("n", "1"))

                // Add tempo marking to the first staff of the first measure.
                if i == 0 && pTrack.staffIndex == 1 {
                    let tempo = makeAttributeElement("tempo", attributes: [
                        "place": "above", "tstamp": "1.0", "midi.bpm": "\(Int(round(piece.tempo)))"
                    ])
                    let dir = XMLElement(name: "dir")
                    dir.addChild(tempo)
                    layer.addChild(dir)
                }

                try populateLayer(layer, events: measuresByTime[i]?[pTrack.staffIndex] ?? [], beatsPerMeasure: 4.0)

                staff.addChild(layer)
                measure.addChild(staff)
            }
            section.addChild(measure)
        }
        return section
    }

    static func populateLayer(_ layer: XMLElement, events: [Event], beatsPerMeasure: Double) throws {
        var beatTracker = 0.0
        let eventsInMeasure = events.sorted(by: { $0.time < $1.time })

        for event in eventsInMeasure {
            let eventStartBeat = event.time.truncatingRemainder(dividingBy: beatsPerMeasure)
            if eventStartBeat > beatTracker {
                try addRests(to: layer, for: eventStartBeat - beatTracker)
            }
            layer.addChild(try buildMusicalEventElement(event: event))
            beatTracker = eventStartBeat + event.dur
        }
        if beatTracker < beatsPerMeasure {
            try addRests(to: layer, for: beatsPerMeasure - beatTracker)
        }
    }
}

// MARK: - Element & Attribute Helpers
private extension MEIConverter {

    static func buildMusicalEventElement(event: Event) throws -> XMLElement {
        if event.pitches.isEmpty { return XMLElement(name: "comment", stringValue: "Empty event") }

        let elementName = event.pitches.count > 1 ? "chord" : "note"
        let element = XMLElement(name: elementName)

        try element.addAttributes(from: durationToAttributes(beats: event.dur))
        if let vel = event.vel {
            element.addAttribute(att("vel", "\(vel)"))
        }

        if event.pitches.count == 1 {
            try element.addAttributes(from: pitchToAttributes(event.pitches[0]))
        } else {
            for pitch in event.pitches {
                let noteElement = XMLElement(name: "note")
                try noteElement.addAttributes(from: pitchToAttributes(pitch))
                element.addChild(noteElement)
            }
        }
        return element
    }

    static func addRests(to layer: XMLElement, for duration: Double) throws {
        if duration <= 0 { return }
        let rest = XMLElement(name: "rest")
        try rest.addAttributes(from: durationToAttributes(beats: duration))
        layer.addChild(rest)
    }

    static func durationToAttributes(beats: Double) throws -> [XMLNode] {
        if beats == 1.5 { return [att("dur", "4"), att("dots", "1")] }
        if beats == 3.0 { return [att("dur", "2"), att("dots", "1")] }
        if beats == 0.75 { return [att("dur", "8"), att("dots", "1")] }

        let standardDurs: [Double: String] = [4.0: "1", 2.0: "2", 1.0: "4", 0.5: "8", 0.25: "16", 0.125: "32"]
        if let dur = standardDurs[beats] {
            return [att("dur", dur)]
        }

        let calculatedDur = 4.0 / beats
        if calculatedDur.rounded() == calculatedDur && [1,2,4,8,16,32,64].contains(Int(calculatedDur)) {
             return [att("dur", "\(Int(calculatedDur))")]
        } else {
            print("Warning: Unsupported duration of \(beats) beats cannot be represented without tuplets. Using fallback.")
            return [att("dur", "4"), att("artic", "stacc")]
        }
    }

    static func pitchToAttributes(_ pitch: PitchValue) throws -> [XMLNode] {
        let p: (pname: String, oct: Int, accid: String?)
        switch pitch {
        case .name(let name): p = try noteNameToPitch(name: name)
        case .midi(let number): p = midiToPitch(midi: number)
        }

        var attributes = [att("pname", p.pname), att("oct", "\(p.oct)")]
        if let accid = p.accid {
            attributes.append(att("accid", accid))
        }
        return attributes
    }

    static func att(_ name: String, _ value: String) -> XMLNode {
        XMLNode.attribute(withName: name, stringValue: value) as! XMLNode
    }

    static func makeAttributeElement(_ name: String, attributes: [String: String]) -> XMLElement {
        let el = XMLElement(name: name)
        for (key, value) in attributes {
            el.addAttribute(att(key, value))
        }
        return el
    }
}

// MARK: - Data Models & Processing

private extension MEIConverter {

    // MARK: Codable JSON Models
    struct Composition: Decodable {
        let title: String?
        let tempo: Double
        let tracks: [Track]
    }
    struct Track: Decodable {
        let instrument: String?
        let events: [Event]
    }
    struct Event: Decodable {
        let time: Double
        let pitches: [PitchValue]
        let dur: Double
        let vel: Int?
    }
    enum PitchValue: Decodable {
        case name(String)
        case midi(Int)
        init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            if let n = try? container.decode(Int.self) { self = .midi(n) }
            else { self = .name(try container.decode(String.self)) }
        }
    }

    // MARK: Internal Processing Models
    class ProcessedTrack {
        let originalTrackIndex: Int
        let staffIndex: Int
        let instrumentName: String
        let label: String
        let midiProgram: Int
        let clef: MEIConstants.ClefInfo

        init(originalTrackIndex: Int, staffIndex: Int, instrumentName: String, label: String, midiProgram: Int, clef: MEIConstants.ClefInfo) {
            self.originalTrackIndex = originalTrackIndex
            self.staffIndex = staffIndex
            self.instrumentName = instrumentName
            self.label = label
            self.midiProgram = midiProgram
            self.clef = clef
        }
    }

    struct ProcessedEvent {
        let event: Event
        let staffIndex: Int
    }

    static func isPiano(_ pTrack: ProcessedTrack) -> Bool {
        MEIConstants.pianoInstrumentNames.contains(pTrack.instrumentName)
    }

    static func processAndCalculateMeasures(piece: Composition, processedTracks: [ProcessedTrack]) throws -> (sortedEvents: [ProcessedEvent], totalMeasures: Int) {
         let allEvents = try piece.tracks.enumerated().flatMap { trackIndex, track -> [ProcessedEvent] in
            let staffsForTrack = processedTracks.filter { $0.originalTrackIndex == trackIndex }
            let isPianoTrack = staffsForTrack.count > 1

            return try track.events.map { event in
                var targetStaffIndex = staffsForTrack.first!.staffIndex
                if isPianoTrack, let trebleStaff = staffsForTrack.first, let bassStaff = staffsForTrack.last {
                    let firstPitchMidi = try pitchToMidi(event.pitches.first ?? .name("C4"))
                    targetStaffIndex = firstPitchMidi >= 60 ? trebleStaff.staffIndex : bassStaff.staffIndex
                }
                return ProcessedEvent(event: event, staffIndex: targetStaffIndex)
            }
        }
        let sortedEvents = allEvents.sorted { $0.event.time < $1.event.time }

        let beatsPerMeasure = 4.0
        let totalBeats = sortedEvents.last.map { $0.event.time + $0.event.dur } ?? 0
        let totalMeasures = totalBeats > 0 ? Int(ceil(totalBeats / beatsPerMeasure)) : 1

        return (sortedEvents, totalMeasures)
    }

    static func groupEventsByMeasure(_ sortedEvents: [ProcessedEvent]) -> [Int: [Int: [Event]]] {
        var measures: [Int: [Int: [Event]]] = [:]
        let beatsPerMeasure = 4.0
        for pEvent in sortedEvents {
            let measureIndex = Int(floor(pEvent.event.time / beatsPerMeasure))
            measures[measureIndex, default: [:]][pEvent.staffIndex, default: []].append(pEvent.event)
        }
        return measures
    }

    static func processTracks(_ tracks: [Track]) throws -> [ProcessedTrack] {
        var processedTracks: [ProcessedTrack] = []
        var staffCount = 0

        for (i, track) in tracks.enumerated() {
            let instrumentName = track.instrument ?? "acoustic_grand_piano"
            guard let midiProgram = MEIConstants.instrumentToMidiProgram[instrumentName] else {
                throw ConversionError.unknownInstrument(instrumentName)
            }

            if MEIConstants.pianoInstrumentNames.contains(instrumentName) {
                staffCount += 1
                let trebleStaff = ProcessedTrack(
                    originalTrackIndex: i, staffIndex: staffCount, instrumentName: instrumentName,
                    label: instrumentName.replacingOccurrences(of: "_", with: " ").capitalized,
                    midiProgram: midiProgram, clef: MEIConstants.treble)
                staffCount += 1
                let bassStaff = ProcessedTrack(
                    originalTrackIndex: i, staffIndex: staffCount, instrumentName: instrumentName,
                    label: "", midiProgram: midiProgram, clef: MEIConstants.bass)
                processedTracks.append(contentsOf: [trebleStaff, bassStaff])
            } else {
                staffCount += 1
                processedTracks.append(ProcessedTrack(
                    originalTrackIndex: i, staffIndex: staffCount, instrumentName: instrumentName,
                    label: instrumentName.replacingOccurrences(of: "_", with: " ").capitalized,
                    midiProgram: midiProgram,
                    clef: MEIConstants.instrumentToClef[instrumentName] ?? MEIConstants.treble
                ))
            }
        }
        return processedTracks
    }
}

// MARK: - Pitch & Note Name Logic
private extension MEIConverter {

    static func noteNameToPitch(name: String) throws -> (pname: String, oct: Int, accid: String?) {
        let pattern = try! NSRegularExpression(pattern: #"^([A-Ga-g])([#sb]?)(\-?\d+)$"#)
        guard let match = pattern.firstMatch(in: name, options: [], range: NSRange(location: 0, length: name.utf16.count)),
              let pRange = Range(match.range(at: 1), in: name),
              let aRange = Range(match.range(at: 2), in: name),
              let oRange = Range(match.range(at: 3), in: name)
        else {
            throw ConversionError.unsupportedPitchFormat(name)
        }

        let pname = String(name[pRange]).lowercased()
        let accidentalStr = String(name[aRange])
        let oct = Int(String(name[oRange])) ?? 4

        let accid: String?
        if accidentalStr == "#" || accidentalStr == "s" { accid = "s" }
        else if accidentalStr == "b" { accid = "f" }
        else { accid = nil }

        return (pname, oct, accid)
    }

    static func midiToPitch(midi: Int) -> (pname: String, oct: Int, accid: String?) {
        let noteNamesWithSharps = ["c", "c", "d", "d", "e", "f", "f", "g", "g", "a", "a", "b"]
        let noteAccidentals: [String?] = [nil, "s", nil, "s", nil, nil, "s", nil, "s", nil, "s", nil]

        let octave = (midi / 12) - 1
        let noteIndex = midi % 12

        return (noteNamesWithSharps[noteIndex], octave, noteAccidentals[noteIndex])
    }

    static func pitchToMidi(_ pitch: PitchValue) throws -> Int {
        switch pitch {
        case .midi(let number):
            return number
        case .name(let name):
            let p = try noteNameToPitch(name: name)
            let noteValues = ["c": 0, "d": 2, "e": 4, "f": 5, "g": 7, "a": 9, "b": 11]
            guard let baseValue = noteValues[p.pname] else {
                throw ConversionError.unsupportedPitchFormat(name)
            }
            var midi = (p.oct + 1) * 12 + baseValue
            if p.accid == "s" { midi += 1 }
            else if p.accid == "f" { midi -= 1 }
            return midi
        }
    }
}

// MARK: - Constants and Mappings
private enum MEIConstants {
    struct ClefInfo { let shape: String; let line: Int }
    static let treble = ClefInfo(shape: "G", line: 2)
    static let bass = ClefInfo(shape: "F", line: 4)
    static let alto = ClefInfo(shape: "C", line: 3)
    static let tenor = ClefInfo(shape: "C", line: 4)

    static let pianoInstrumentNames: Set<String> = [
        "acoustic_grand_piano", "bright_acoustic_piano", "electric_grand_piano",
        "honky_tonk_piano", "electric_piano_1", "electric_piano_2",
        "harpsichord", "clavinet"
    ]

    static let instrumentToClef: [String: ClefInfo] = [
        "violin": treble, "viola": alto, "cello": bass, "contrabass": bass,
        "flute": treble, "piccolo": treble, "oboe": treble, "clarinet": treble,
        "bassoon": bass, "recorder": treble, "soprano_sax": treble, "alto_sax": treble,
        "tenor_sax": treble, "baritone_sax": treble, "trumpet": treble,
        "trombone": bass, "tuba": bass, "muted_trumpet": treble, "french_horn": treble,
        "acoustic_guitar_nylon": treble, "acoustic_guitar_steel": treble,
        "acoustic_bass": bass, "electric_bass_finger": bass, "electric_bass_pick": bass
    ]

    static let instrumentToMidiProgram: [String: Int] = [
        "acoustic_grand_piano": 1, "bright_acoustic_piano": 2, "electric_grand_piano": 3, "honky_tonk_piano": 4,
        "electric_piano_1": 5, "electric_piano_2": 6, "harpsichord": 7, "clavinet": 8, "celesta": 9,
        "glockenspiel": 10, "music_box": 11, "vibraphone": 12, "marimba": 13, "xylophone": 14,
        "tubular_bells": 15, "drawbar_organ": 17, "church_organ": 20, "accordion": 22, "harmonica": 23,
        "acoustic_guitar_nylon": 25, "acoustic_guitar_steel": 26, "electric_guitar_jazz": 27,
        "electric_guitar_clean": 28, "electric_guitar_muted": 29, "overdriven_guitar": 30,
        "distortion_guitar": 31, "acoustic_bass": 33, "electric_bass_finger": 34, "electric_bass_pick": 35,
        "fretless_bass": 36, "slap_bass_1": 37, "slap_bass_2": 38, "violin": 41, "viola": 42, "cello": 43,
        "contrabass": 44, "tremolo_strings": 45, "pizzicato_strings": 46, "orchestral_harp": 47,
        "string_ensemble_1": 49, "string_ensemble_2": 50, "choir_aahs": 53, "voice_oohs": 54, "trumpet": 57,
        "trombone": 58, "tuba": 59, "muted_trumpet": 60, "french_horn": 61, "brass_section": 62,
        "soprano_sax": 65, "alto_sax": 66, "tenor_sax": 67, "baritone_sax": 68, "oboe": 69, "bassoon": 71,
        "clarinet": 72, "piccolo": 73, "flute": 74, "recorder": 75
    ]
}

// Helper extension to add attributes from an array
fileprivate extension XMLElement {
    func addAttributes(from nodes: [XMLNode]) throws {
        for node in nodes {
            if let attribute = node as? XMLNode, attribute.kind == .attribute {
                self.addAttribute(attribute)
            }
        }
    }
}
